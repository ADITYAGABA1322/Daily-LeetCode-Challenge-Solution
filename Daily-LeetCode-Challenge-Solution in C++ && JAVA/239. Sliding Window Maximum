239. Sliding Window Maximum


16 August 2023


Hard


C++:


// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq; // deque
        vector<int> ans; // vector to store the result
        for(int i=0; i<nums.size(); i++){ // loop for i
            while(!dq.empty() && dq.back() < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop_back(); // pop the last element from the deque
            }
            dq.push_back(nums[i]); // push the element in the deque
            if(i >= k-1){ // if i is greater than or equal to k-1
                ans.push_back(dq.front()); // push the front element of the deque in the ans
                if(nums[i-k+1] == dq.front()){ // if the front element of the deque is equal to nums[i-k+1]
                    dq.pop_front(); // pop the front element from the deque
                }d
            }
        }
        return ans; // return the ans
    }
};



Java:

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)  

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> dq = new LinkedList<>(); // deque
        int[] ans = new int[nums.length-k+1]; // vector to store the result
        for(int i=0; i<nums.length; i++){ // loop for i
            while(!dq.isEmpty() && dq.peekLast() < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pollLast(); // pop the last element from the deque
            }
            dq.offer(nums[i]); // push the element in the deque
            if(i >= k-1){ // if i is greater than or equal to k-1
                ans[i-k+1] = dq.peekFirst(); // push the front element of the deque in the ans
                if(nums[i-k+1] == dq.peekFirst()){ // if the front element of the deque is equal to nums[i-k+1]
                    dq.pollFirst(); // pop the front element from the deque
                }
            }
        }
        return ans; // return the ans
    }
}



Python:

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        dq = collections.deque() # deque
        ans = [] # vector to store the result
        for i in range(len(nums)): # loop for i
            while dq and dq[-1] < nums[i]: # if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop() # pop the last element from the deque
            dq.append(nums[i]) # push the element in the deque
            if i >= k-1: # if i is greater than or equal to k-1
                ans.append(dq[0]) # push the front element of the deque in the ans
                if nums[i-k+1] == dq[0]: # if the front element of the deque is equal to nums[i-k+1]
                    dq.popleft() # pop the front element from the deque
        return ans # return the ans


Python3:

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

class Solution:
    def maxSlidingWindow(self, nums: List[int, k: int) -> List[int]: # add the missing bracket after List[int]
        dq = collections.deque() # deque
        ans = [] # vector to store the result
        for i in range(len(nums)): # loop for i
            while dq and dq[-1] < nums[i]: # if the deque is not empty and the last element of the deque is less than nums[i]
                dq.pop() # pop the last element from the deque
            dq.append(nums[i]) # push the element in the deque
            if i >= k-1: # if i is greater than or equal to k-1
                ans.append(dq[0]) # push the front element of the deque in the ans
                if nums[i-k+1] == dq[0]: # if the front element of the deque is equal to nums[i-k+1]
                    dq.popleft() # pop the front element from the deque
        return ans # return the ans



C:

// Time Complexity : O(n) where n is the size of the vector nums and space complexity is O(k)

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    int* ans = (int*)malloc(sizeof(int)*(numsSize-k+1)); // vector to store the result
    int index = 0; // variable to store the index
    int* dq = (int*)malloc(sizeof(int)*numsSize); // deque
    int front = 0; // variable to store the front
    int rear = 0; // variable to store the rear
    for(int i=0; i<numsSize; i++){ // loop for i
        while(front != rear && dq[front] < nums[i]){ // if the deque is not empty and the last element of the deque is less than nums[i]
            front++; // increment the front
        }
        dq[front++] = nums[i]; // push the element in the deque
        if(i >= k-1){ // if i is greater than or equal to k-1
            ans[index++] = dq[rear]; // push the front element of the deque in the ans
            if(nums[i-k+1] == dq[rear]){ // if the front element of the deque is equal to nums[i-k+1]
                rear++; // increment the rear
            }
        }
    }
    *returnSize = index; // update the returnSize
    return ans; // return the ans
}


C#:



Javascript:



Swift:


Dart:

