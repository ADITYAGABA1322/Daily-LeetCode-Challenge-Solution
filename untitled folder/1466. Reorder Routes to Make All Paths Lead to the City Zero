1466. Reorder Routes to Make All Paths Lead to the City Zero



24 March 2023




Medium






C++:


// Time Complexity : O(n) where n is the number of edges and space complexity is O(n) where n is the number of edges





class Solution {
public:
    int minReorder(int n, vector<vector<int>>& connections) {
        vector<vector<int>> graph(n);  // create a graph
        for(int i = 0; i < connections.size(); i++){  // iterate through the connections
            graph[connections[i][0]].push_back(connections[i][1]);  // add the edge
            graph[connections[i][1]].push_back(-connections[i][0]);  // add the edge
        }
        vector<bool> visited(n, false);  // create a visited array
        return dfs(graph, visited, 0);  // return the result
    }
    int dfs(vector<vector<int>>& graph, vector<bool>& visited, int node){  // function to perform dfs
        visited[node] = true;  // update the visited array
        int result = 0;  // variable to store the result
        for(int i = 0; i < graph[node].size(); i++){  // iterate through the graph
            int child = graph[node][i];  // get the child
            if(child > 0){  // if the child is greater than 0
                if(!visited[child]){  // if the child is not visited
                    result += 1 + dfs(graph, visited, child);  // update the result
                }
            }
            else{  // if the child is less than 0
                if(!visited[-child]){  // if the child is not visited
                    result += dfs(graph, visited, -child);  // update the result
                }
            }
        }
        return result;  // return the result
    }
};



Java:


// Time Complexity : O(n) where n is the number of edges and space complexity is O(n) where n is the number of edges





class Solution {
    public int minReorder(int n, int[][] connections) {
        List<Integer>[] graph = new ArrayList[n];  // create a graph
        for(int i = 0; i < n; i++){  // iterate through the array
            graph[i] = new ArrayList<>();  // create a new list
        }
        for(int i = 0; i < connections.length; i++){  // iterate through the connections
            graph[connections[i][0]].add(connections[i][1]);  // add the edge
            graph[connections[i][1]].add(-connections[i][0]);  // add the edge
        }
        boolean[] visited = new boolean[n];  // create a visited array
        return dfs(graph, visited, 0);  // return the result
    }
    public int dfs(List<Integer>[] graph, boolean[] visited, int node){  // function to perform dfs
        visited[node] = true;  // update the visited array
        int result = 0;  // variable to store the result
        for(int i = 0; i < graph[node].size(); i++){  // iterate through the graph
            int child = graph[node].get(i);  // get the child
            if(child > 0){  // if the child is greater than 0
                if(!visited[child]){  // if the child is not visited
                    result += 1 + dfs(graph, visited, child);  // update the result
                }
            }
            else{  // if the child is less than 0
                if(!visited[-child]){  // if the child is not visited
                    result += dfs(graph, visited, -child);  // update the result
                }
            }
        }
        return result;  // return the result
    }
}


